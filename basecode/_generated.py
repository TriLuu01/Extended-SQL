
import copy
import os
import psycopg2
import psycopg2.extras
import tabulate
from dotenv import load_dotenv

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

# Search for a given "group by" attrib. value(s) in mf_struct
def lookup(cur_row, V, NUM_OF_ENTRIES, mf_struct):
    for i in range(NUM_OF_ENTRIES):
        num_same = len(V)
        for attrib in V:
            if mf_struct[i][attrib] == cur_row[attrib]:
                num_same -= 1
            if num_same == 0:
                return i
    return -1

# Adds a new entry in mf_struct, corresponding to a newly found "group by" attrib. value
def add(cur_row, V, NUM_OF_ENTRIES, mf_struct):
    for attrib in V:
        mf_struct[NUM_OF_ENTRIES][attrib] = cur_row[attrib]
    NUM_OF_ENTRIES += 1
    return NUM_OF_ENTRIES, mf_struct


def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    
    _global = []
    
    S = ['cust', 'prod', 'avg_1_quant', 'avg_2_quant', 'avg_3_quant', 'min_3_quant', 'max_3_quant'] #  1. S - projected columns / expressions
    n = 3 #  2. n - number of grouping variables
    V = ['cust', 'prod'] #  3. V - grouping attributes
    F_Vect = ['avg_1_quant', 'avg_2_quant', 'avg_3_quant', 'min_3_quant', 'max_3_quant'] #  4. F-VECT - vector of aggregate functions
    Pred_List = ["1.state = 'NY'", "2.state = 'NJ'", "3.state = 'CT'"] #  5. PRED-LIST - list of predicates for grouping
    Having = "None" #  6. HAVING

    # Generate the code for mf_struct
    base_struct = dict()
    for attrib in V:
        base_struct[attrib] = None
    for agg in F_Vect:
        split_agg = agg.split("_")
        if split_agg[0] == 'avg':
            base_struct[agg] = [0, 0] # Create a list to store sum and count to compute the average
        elif split_agg[0] == 'min':
            base_struct[agg] = float('-inf')
        elif split_agg[0] == 'max':
            base_struct[agg] = float('inf')
        else:
            base_struct[agg] = 0
    mf_struct = []
    for i in range(2000):
        mf_struct.append(copy.deepcopy(base_struct))
    NUM_OF_ENTRIES = 0
    NEW_NUM_OF_ENTRIES = 0

    # Populate mf-struct with distinct values of grouping attribute
    for row in cur:
        # Look up current_row.cust in mf_struct
        pos = lookup(row, V, NUM_OF_ENTRIES, mf_struct)
        if pos == -1:
            NUM_OF_ENTRIES, mf_struct = add(row, V, NUM_OF_ENTRIES, mf_struct)
    
    cur.scroll(0,'absolute')

    for row in cur:
        # Look up current_row.cust in mf_struct
        pos = lookup(row, V, NUM_OF_ENTRIES, mf_struct)
        if row['state'] == 'NY':
            # Current_row.cust found in mf_struct
            mf_struct[pos]['avg_1_quant'][0] += row['quant']
            mf_struct[pos]['avg_1_quant'][1] += 1
    for i in range(NUM_OF_ENTRIES):
        mf_struct[i]['avg_1_quant'] = mf_struct[i]['avg_1_quant'][0] / mf_struct[i]['avg_1_quant'][1]

    cur.scroll(0,'absolute')

    for row in cur:
        # Look up current_row.cust in mf_struct
        pos = lookup(row, V, NUM_OF_ENTRIES, mf_struct)
        if row['state'] == 'NJ':
            # Current_row.cust found in mf_struct
            mf_struct[pos]['avg_2_quant'][0] += row['quant']
            mf_struct[pos]['avg_2_quant'][1] += 1
    for i in range(NUM_OF_ENTRIES):
        mf_struct[i]['avg_2_quant'] = mf_struct[i]['avg_2_quant'][0] / mf_struct[i]['avg_2_quant'][1]

    cur.scroll(0,'absolute')

    for row in cur:
        # Look up current_row.cust in mf_struct
        pos = lookup(row, V, NUM_OF_ENTRIES, mf_struct)
        if row['state'] == 'CT':
            # Current_row.cust found in mf_struct
            mf_struct[pos]['avg_3_quant'][0] += row['quant']
            mf_struct[pos]['avg_3_quant'][1] += 1
            if mf_struct[pos]['min_3_quant'] == float('-inf'): mf_struct[pos]['min_3_quant'] = row['quant']
            if row['quant'] < mf_struct[pos]['min_3_quant']: mf_struct[pos]['min_3_quant'] = row['quant']
            if mf_struct[pos]['max_3_quant'] == float('inf'): mf_struct[pos]['max_3_quant'] = row['quant']
            if row['quant'] > mf_struct[pos]['max_3_quant']: mf_struct[pos]['max_3_quant'] = row['quant']
    for i in range(NUM_OF_ENTRIES):
        mf_struct[i]['avg_3_quant'] = mf_struct[i]['avg_3_quant'][0] / mf_struct[i]['avg_3_quant'][1]

    for i in range(NUM_OF_ENTRIES):
        _global.append(mf_struct[i]); NEW_NUM_OF_ENTRIES += 1
    for i in range(NEW_NUM_OF_ENTRIES):
        for col in set(F_Vect) - set(S):
            del _global[i][col]
    
    return tabulate.tabulate(_global,
                        headers="keys", tablefmt="psql")

def main():
    print(query())
    
if "__main__" == __name__:
    main()
